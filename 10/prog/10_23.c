/*印出陣列的位置*/
#include<stdio.h>
int main(void)
{
    int num[3][4] = {{12,23,42,18},
                     {43,22,19,28},
                     {31,13,19,28}};
    int m,n;

    for(m = 0; m < 3; m++)
        for(n = 0;n < 4; n++)
            printf("num[%d][%d]=%d,位址=%p\n", m, n, *(*(num+m)+n), *(num+m)+n);

    printf("\n");
    printf("**num=%d\n", **num);


    return 0;
}

/*輸出結果：
num[0][0]=12,位址=0x7ff7b5539e30
num[0][1]=23,位址=0x7ff7b5539e34
num[0][2]=42,位址=0x7ff7b5539e38
num[0][3]=18,位址=0x7ff7b5539e3c
num[1][0]=43,位址=0x7ff7b5539e40
num[1][1]=22,位址=0x7ff7b5539e44
num[1][2]=19,位址=0x7ff7b5539e48
num[1][3]=28,位址=0x7ff7b5539e4c
num[2][0]=31,位址=0x7ff7b5539e50
num[2][1]=13,位址=0x7ff7b5539e54
num[2][2]=19,位址=0x7ff7b5539e58
num[2][3]=28,位址=0x7ff7b5539e5c

**num=12
-------------------------------
二維陣列存取等價關係： num[m][n]  <=>  *(*(num + m) + n)

----------------------------------------------------------------------
1.  *(num + m) + n  (位址存取 - 位於等號右側)
----------------------------------------------------------------------
    -   運算過程：
        a. (num + m)：指標算術，跳過 m 整個「行」 (m * 16 bytes)，找到第 m 行的起始地址。
        b. *(num + m)：對該地址解參考，得到第 m 行這個一維陣列。
        c. + n：對這個一維陣列的起始地址，再執行指標算術，向前移動 n 個「元素」 (n * 4 bytes)。
    -   結果：最終是一個【地址】，指向 num[m][n] 這個元素。
    -   應用：用於 %p 輸出，或作為賦值的右側，或作為下一次解參考的目標。

----------------------------------------------------------------------
2.  *(*(num + m) + n) (值存取 - 位於等號左側或右側)
----------------------------------------------------------------------
    -   運算過程：在 (num + m) + n 計算出最終地址後，再執行【最後一次解參考 (*)】。
    -   結果：是一個【整數值】，即 num[m][n] 的內容。
    -   應用：可作為 L-value (賦值左側，用於修改 num[m][n] 的值) 或 R-value (賦值右側，用於讀取值)。

    簡單來說 *(num + m) + n 為位址， *(*(num + m) + n) 為值*/